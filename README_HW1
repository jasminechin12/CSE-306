In this homework exercise, we first separated the mouse data from the keyboard data. This was done in kbd.c in kbdgetc() where we read the data byte from port 0x60 and inspected bit 5. We knew that if bit 5 was set, then the data came from the mouse and then we proceeded to discard it because we only wanted keyboard data. Then, we had to initialize the mouse so we created our own mouse.c file and in our mouseinit() function, we first issued the get compaq status byte command and grabbed the status byte that was returned. We set bit 1 and cleared bit 5 in this byte. After, we sent 0x60 to the control port and then sent the modified byte to port 0x60. We then sent 0xD4 to the PS/2 controller and 0xF4 command to port 0x60 to activate the mouse. We used the ioapicenable function to tell the interrupt controller we want to receive mouse interrupts. We also initialized our spin and sleep lock and buffer at this point. We called our mouseinit function after we called consoleinit() in main.c. In our mouseintr function (in mouse.c), we acquired the mouselock and created a while loop to continuously read in mouse data. The while loop condition checked if there was data to be read and if there was, we checked if the first byte had bit 3 set. If not, we discarded it and continuously read the data until we had data that matched the first byte description. Once we had the first byte, we read in the next two bytes for the packet and checked the first byte again to see if there was x or y overflow. If there was, we discarded the data packet. If there wasn't, we put the 3 byte packet into the circular buffer. We then created a new system call function readmouse() so the user can get mouse data. In that function, we checked if the parameter that was passed into the function was a valid pointer to a block of memory. If it was, the mouse_syscall_helper() we created in mouse.c to obtain mouse data from the buffer, returns the data packet and it is then stored in the pointer that was passed as the paramater for the system call. The data packet is then processed and printed out as output.

To compile the program, in terminal, type "make qemu" and in QEMU, type "usertestprog &" and hit ENTER. This way, you still have access to the shell while the program runs in the background as a separate process. The program will listen for mouse data from the mouse device. You should be able to move the mouse and click mouse buttons and receive output based on mouse data. When you left click, the state of "Left Btn" will be "Pressed" and when you release, the state will be "Released". This applies to the right and middle button. If you press the left and right button at the same time, it will register as the middle button being pressed

To terminate the program, hit ctrl-p to see the processes that are running and their process IDs. In terminal, type "kill [pid]" where you replace [pid] with the process id of usertestprog. Once you kill the program, "zombie!" should be printed. Any backed up mouse data still in the buffer will be printed if you wish to run the test program again without terminating QEMU.

The circular buffer we chose to create was an array of integers with a read_index, write_index and count. We picked an array because it was easier to use and it was an int array because the data packets are 3 bytes. We had a count to keep track of how many items were in the buffer at a time and the read_index and write_index are used to keep track of where the read and/or write. The circular buffer holds 100 data packets at a time. When the buffer is full, any new mouse data is discarded. If you wish to see the debugging message, you can go into mouse.c and un-comment line 78 in insert();


